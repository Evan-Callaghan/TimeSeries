---
title: "Data Simulation Demonstration"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r imputer_functions, include=FALSE}
## Defining all functions
## -----------------------

#' simulator
#' 
#' Main function for the "simulate" file. The "method" parameter determines which method is used
#' to generate the neural network training data:
#' 
#' Method 1: Data is generated by first estimating the trend and periodic components, computing the 
#' residual noise between the estimate and the current version of the imputed series, perturbing the 
#' noise series, and then adding the perturbed noise back to the estimate series.
#' 
#' Method 2: Data is generated by first removing the trend and the mean, perturbing the de-trended
#' series, and then adding the mean and trend back to the perturbed series.
#' 
#' Method 3: Data is generated by first estimating the trend and periodic components, computing the 
#' residual noise between the estimate and the current version of the imputed series, perturbing the 
#' noise series, perturbing the trend + periodic series, and then adding the two perturbed series 
#' back together.
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' @param method {string}; Method for data simulation in c('noise', 'all', 'separate')
#' 
simulator <- function(x0, xV, n_series, p, g, K, random = TRUE, 
                      method = 'noise', Mod_a, Mod_b, Arg_a, Arg_b){

  ## Case 1:
  if (method == 'noise'){
    xE = estimator(xV, method = 'Xt') ## Estimating trend + period
    data = simulator_noise(x0, xV, xE, n_series, p, g, K, random) ## Simulating data
    inputs = data[[1]]; targets = data[[2]]
    return(list(inputs, targets))
  }
  
  ## Case 2: Data is generated by 
  else if (method == 'all'){
    Mt = estimator(xV, method = 'Mt')
    data = simulator_all(x0, xV, Mt, n_series, p, g, K, random = TRUE)
    inputs = data[[1]]; targets = data[[2]]
    return(list(inputs, targets))
    # Do something...
  }
  else if (method == 'separate'){
    xE = estimator(xV, method = 'Xt') ## Estimating trend + period
    data = simulator_separate(x0, xV, xE, n_series, p, g, K, random) ## Simulating data
    inputs = data[[1]]; targets = data[[2]]
    return(list(inputs, targets))
  }
}


#' simulator_noise
#' 
#' Function to simulate training data for method = 'noise' (i.e., follows Method 1 described above).
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param xE {list}; List containing the current trend + periodic estimates of xV ("x estimate")
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' 
simulator_noise <- function(x0, xV, xE, n_series, p, g, K, random = TRUE){
  if (random == FALSE){K = 1}
  N = length(xV); M = n_series * K ## Defining useful parameters
  inputs_temp = c(); targets_temp = c() ## Initializing vectors to store values
  w = xV - xE ## Computing the residual noise
  w_f = fft(w, inverse = FALSE) ## Converting noise to frequency domain
  
  if (random == TRUE){
    for (i in 1:n_series){
      w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b)) ## Creating small perturbation
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE + w_t ## Adding perturbed noise back to trend and periodic
      x_g = simulateGaps(list(x_p), p = p, g = g, K = K) ## Imposing gap structure
      
      for (k in 1:K){
        structure = paste0('x_g[[1]]$p', p, '$g', g, '[[k]]')
        inputs_temp = c(inputs_temp, eval(parse(text = structure))) ## Appending inputs
        targets_temp = c(targets_temp, x_p) ## Appending targets
      }
    }
  }
  
  else if (random == FALSE){
    g_index = which(is.na(x0)) ## Defining useful parameters
    for (i in 1:n_series){
      w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b)) ## Creating small perturbation
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE + w_t ## Adding perturbed noise back to trend and periodic
      x_g = x_p; x_g[g_index] = NA ## Imposing non-randomized gap structure
      inputs_temp = c(inputs_temp, x_g) ## Appending inputs
      targets_temp = c(targets_temp, x_p) ## Appending targets
    }
  }
  
  inputs = array(matrix(inputs_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting inputs
  targets = array(matrix(targets_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting targets
  preprocessed = preprocess(inputs, targets) ## Preprocessing
  inputs = preprocessed[[1]]; targets = preprocessed[[2]]
  return(list(inputs, targets))
}


#' simulator_all
#' 
#' Function to simulate training data for method = 'all' (i.e., follows Method 2 described above).
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param Mt {list}; List containing the estimated trend component
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' 
simulator_all <- function(x0, xV, Mt, n_series, p, g, K, random = TRUE){
  if (random == FALSE){K = 1}
  N = length(xV); M = n_series * K ## Defining useful parameters
  inputs_temp = c(); targets_temp = c() ## Initializing vectors to store values
  
  Y = xV - Mt ## De-trending
  Z = Y - mean(Y) ## Zero-mean
  
  Z_f = fft(Z, inverse = FALSE) ## Converting noise to frequency domain
  
  if (random == TRUE){
    for (i in 1:n_series){
      Z_p = Z_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b)) ## Creating small perturbation
      Z_t = as.numeric(fft(Z_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = Z_t + mean(Y) + Mt ## Adding perturbed noise back to trend and periodic
      x_g = simulateGaps(list(x_p), p = p, g = g, K = K) ## Imposing gap structure
      
      for (k in 1:K){
        structure = paste0('x_g[[1]]$p', p, '$g', g, '[[k]]')
        inputs_temp = c(inputs_temp, eval(parse(text = structure))) ## Appending inputs
        targets_temp = c(targets_temp, x_p) ## Appending targets
      }
    }
  }
  
  else if (random == FALSE){
    g_index = which(is.na(x0)) ## Defining useful parameters
    for (i in 1:n_series){
      Z_p = Z_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b)) ## Creating small perturbation
      Z_t = as.numeric(fft(Z_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = Z_t + mean(Y) + Mt ## Adding perturbed noise back to trend and periodic
      x_g = x_p; x_g[g_index] = NA ## Imposing non-randomized gap structure
      inputs_temp = c(inputs_temp, x_g) ## Appending inputs
      targets_temp = c(targets_temp, x_p) ## Appending targets
    }
  }
  
  inputs = array(matrix(inputs_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting inputs
  targets = array(matrix(targets_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting targets
  preprocessed = preprocess(inputs, targets) ## Preprocessing
  inputs = preprocessed[[1]]; targets = preprocessed[[2]]
  return(list(inputs, targets))
}


#' simulator_separate
#' 
#' Function to simulate training data for method = 'separate' (i.e., follows Method 3 described above).
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param xE {list}; List containing the current trend + periodic estimates of xV ("x estimate")
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' 
simulator_separate <- function(x0, xV, xE, n_series, p, g, K, random = TRUE){
  if (random == FALSE){K = 1}
  N = length(xV); M = n_series * K ## Defining useful parameters
  inputs_temp = c(); targets_temp = c() ## Initializing vectors to store values
  w = xV - xE ## Computing the residual noise
  xE_f = fft(xE, inverse = FALSE) ## Converting estimate to frequency domain
  w_f = fft(w, inverse = FALSE) ## Converting noise to frequency domain
  
  if (random == TRUE){
    for (i in 1:n_series){
      xE_p = xE_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
      w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
      xE_t = as.numeric(fft(xE_p, inverse = TRUE)) / N ## Converting back to time domain
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE_t + w_t ## Adding perturbed noise back to trend and periodic
      x_g = simulateGaps(list(x_p), p = p, g = g, K = K) ## Imposing gap structure
      
      for (k in 1:K){
        structure = paste0('x_g[[1]]$p', p, '$g', g, '[[k]]')
        inputs_temp = c(inputs_temp, eval(parse(text = structure))) ## Appending inputs
        targets_temp = c(targets_temp, x_p) ## Appending targets
      }
    }
  }
  
  else if (random == FALSE){
    g_index = which(is.na(x0)) ## Defining useful parameters
    for (i in 1:n_series){
      xE_p = xE_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
      w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
      xE_t = as.numeric(fft(xE_p, inverse = TRUE)) / N ## Converting back to time domain
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE_t + w_t ## Adding perturbed noise back to trend and periodic
      x_g = x_p; x_g[g_index] = NA ## Imposing non-randomized gap structure
      inputs_temp = c(inputs_temp, x_g) ## Appending inputs
      targets_temp = c(targets_temp, x_p) ## Appending targets
    }
  }
  
  inputs = array(matrix(inputs_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting inputs
  targets = array(matrix(targets_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting targets
  preprocessed = preprocess(inputs, targets) ## Preprocessing
  inputs = preprocessed[[1]]; targets = preprocessed[[2]]
  return(list(inputs, targets))
}


#' preprocess
#' 
#' Function to preprocess the data before building the neural network imputer. The function performs 0-1
#' standardization for each time series in the input and target matrix.
#' @param inputs {matrix}; Matrix object containing the input training data (i.e., an incomplete 
#'                         time series in each row)
#' @param targets {matrix}; Matrix object containing the target training data (i.e., a complete 
#'                         time series in each row)
#' 
preprocess <- function(inputs, targets){
  for (i in 1:dim(inputs)[1]){
    inputs[i,] = (inputs[i,] - min(targets[i,])) / (max(targets[i,]) - min(targets[i,])) 
    targets[i,] = (targets[i,] - min(targets[i,])) / (max(targets[i,]) - min(targets[i,]))
    
    inputs[i,] = ifelse(is.na(inputs[i,]), -1, inputs[i,])
  }
  return(list(inputs, targets))
}


#' estimator
#' 
#' Main function for the "estimate" file. The "method" parameter determines which method should 
#' be returned:
#' Case 1: Returning the trend + periodic component(s)
#' Case 2: Returning the trend component
#' Case 3: Returning the periodic component(s)
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param method {string}; Case in c('Xt', 'Mt', 'Tt')
#' 
estimator <- function(xV, method = 'Xt'){
  Mt = estimateMt(x = xV, N = length(xV), nw = 5, k = 8, pMax = 2) ## Estimating trend component
  Tt = estimateTt(x = xV - Mt, epsilon = 1e-6, dT = 1, nw = 5, k = 8, sigClip = 0.999) ## Estimating periodic components
  Xt = Mt ## Combining trend and periodic
  for (i in 1:dim(Tt)[2]){
    Xt = Xt + Tt[,i]
  }
  if (method == 'Xt'){return(Xt)}
  else if (method == 'Mt'){return(Mt)}
  else if (method == 'Tt'){return(Tt)}
}

estimateMt <- function(x, N, nw, k, pMax) {
  V <- dpss(n = N, nw = 5, k = 8)$v
  test <- dpssap(V, pMax) # fit quadratic
  U <- test[[1]]
  R <- test[[2]]
  Y <- t(V) %*% x
  a <- t(U) %*% Y
  r <- Y - U %*% a
  xhat <- V %*% r + R %*% a
  phat <- R %*% a
  return(phat)
}

estimateTt <- function(x, epsilon, dT, nw, k, sigClip, progress=FALSE, freqIn=NULL) {
  
  ################################################################################
  # Algorithm step 1: spectrum/Ftest pilot estimate
  pilot <- spec.mtm(x, deltat=dT, nw=nw, k=k, Ftest=TRUE, plot=FALSE)
  
  if(is.null(freqIn)) {
    ################################################################################
    # Algorithm step 2: estimate significant peaks (sigClip)
    fmesh <- pilot$mtm$Ftest
    fsig <- fmesh > qf(sigClip, 2, pilot$mtm$k)
    floc <- which(fsig==TRUE)
    if(length(floc > 0)) {
      ###########################################################################   
      delta <- floc[2:length(floc)] - floc[1:(length(floc)-1)]
      if(length(which(delta==1)) > 0) {
        bad <- which(delta==1)
        if(!is.null(bad)) {
          if(progress) {
            for(j in 1:length(bad)) {
              cat(paste("Peak at ", formatC(pilot$freq[floc[bad[j]]], width=6, format="f"),
                        "Hz is smeared across more than 1 bin. \n", sep=""))
            } 
          }
        }
        floc <- floc[-bad] # eliminate the duplicates
      }
      
      ################################################################################
      # Algorithm step 3: estimate centers
      dFI <- pilot$freq[2]
      # epsilon <- 1e-10
      maxFFT <- 1e20
      max2 <- log(maxFFT, base=2)
      max3 <- log(maxFFT, base=3)
      max5 <- log(maxFFT, base=5)
      max7 <- log(maxFFT, base=7)
      
      freqFinal <- matrix(data=0, nrow=length(floc), ncol=1)
      
      for(j in 1:length(floc)) {
        if(progress) {
          cat(".")  
        }
        f0 <- pilot$freq[floc[j]]
        
        if(progress) {
          cat(paste("Optimizing Peak Near Frequency ", f0, "\n", sep=""))
        }
        
        # increasing powers of 2,3,5,7 on nFFT until peak estimate converges
        pwrOrig <- floor(log2(pilot$mtm$nFFT)) + 1
        fI <- f0
        converge <- FALSE
        
        for(k7 in 0:max7) {
          for(k5 in 0:max5) {
            for(k3 in 0:max3) {
              for(k2 in 1:max2) {
                
                if(!converge) {
                  nFFT <- 2^pwrOrig * 2^k2 * 3^k3 * 5^k5 * 7^k7
                  tmpSpec <- spec.mtm(x, deltat=dT, nw=5, k=8, plot=FALSE, Ftest=TRUE,
                                      nFFT=nFFT)
                  dF <- tmpSpec$freq[2]
                  f0loc <- which(abs(tmpSpec$freq - f0) <= dF)
                  range <- which(tmpSpec$freq <= (f0+1.1*dFI) & tmpSpec$freq >= (f0-1.1*dFI))
                  
                  fI2 <- tmpSpec$freq[which(tmpSpec$mtm$Ftest == max(tmpSpec$mtm$Ftest[range]))]
                  if(abs(fI - fI2) > epsilon) {
                    fI <- fI2
                  } else {
                    fF <- fI2
                    converge <- TRUE
                  }
                }
              }}}}
        freqFinal[j] <- fF
        if(progress) {
          cat(paste("Final frequency estimate: ", fF, "\n", sep=""))
        }
      }
      if(progress) {
        cat("\n")
      }
    } else {
      freqFinal <- NULL
      floc <- -1
    } # end of "there are freqs detected"
  } else {  # case where frequencies are already obtained
    freqFinal <- freqIn
    floc <- 1:length(freqFinal)
    if(length(freqFinal)==1 & freqFinal[1]==0) {
      floc <- -1
    }
  }
  ################################################################################
  # Algorithm step 4: frequencies obtained, estimate phase and amplitude
  #    by inverting the spectrum (i.e. line component removal)
  if(length(floc) > 1 | floc[1] > 0) {
    sinusoids <- matrix(data=0, nrow=length(x), ncol=length(floc))
    amp <- matrix(data=0, nrow=length(floc), ncol=1)
    phse <- matrix(data=0, nrow=length(floc), ncol=1)
    N <- length(x)
    t <- seq(1, N*dT, dT)
    
    for(j in 1:length(floc)) {
      sinusoids[, j] <- removePeriod(x, freqFinal[j], nw=5, k=8, deltaT=dT, warn=FALSE, prec=1e-10, sigClip=sigClip) 
      fit <- lm(sinusoids[, j] ~ sin(2*pi*freqFinal[j]*t) + cos(2*pi*freqFinal[j]*t) - 1)
      phse[j] <- atan(fit$coef[2] / fit$coef[1])
      amp[j] <- fit$coef[1] / cos(phse[j])
    }
    
    attr(sinusoids, "Phase") <- phse
    attr(sinusoids, "Amplitude") <- amp
    attr(sinusoids, "Frequency") <- freqFinal
    return(sinusoids)
  } else {
    sinusoids <- matrix(data=0, nrow=length(x), ncol=length(floc))
    attr(sinusoids, "Phase") <- 0
    attr(sinusoids, "Amplitude") <- 0
    attr(sinusoids, "Frequency") <- 0
    return(sinusoids)
  }
}

dpssap <- function(V, maxdeg) {
  
  # Sanity checks
  stopifnot(is.matrix(V), is.numeric(maxdeg), maxdeg>=0)
  N <- length(V[, 1])
  K <- length(V[1, ])
  P <- maxdeg + 1
  timeArr <- 1:N
  
  R <- matrix(data=0, nrow=N, ncol=P)
  U <- matrix(data=0, nrow=K, ncol=P)
  
  # Setup centered time index
  midTime <- (1+N) / 2
  scl <- 2/(N-1)
  timeArrC <- (timeArr - midTime) * scl
  
  # Start with Gegenbauer polynomials; convergence is faster
  alpha <- 0.75
  R[, 1] <- 1.0
  if(maxdeg > 0) {
    R[, 2] <- 2 * alpha * timeArrC
    if(maxdeg > 1) {
      for(j in 2:maxdeg) {
        A1 <- 2 * ( (j-1) + alpha ) / j
        A2 <- ( (j-2) + 2 * alpha ) / j
        
        R[, (j+1)] <- A1 * timeArrC * R[, j] - A2 * R[, (j-1)]
      } # end of loop on higher orders
    } # end of maxdeg > 1
  } # end of maxdeg > 0
  
  # Inner Products of R and V
  for(L in 1:P) {
    Kmin <- ( (L-1) %% 2 ) + 1
    for(k in seq(Kmin, K, 2)) {  # loop on non-zero Slepians
      U[k, L] <- t(V[, k]) %*% R[, L]
    }
  }
  
  # Degree 0, 1 (manual) -- L = degree+1
  for(L in 1:min(2,P)) {
    scl <- 1 / sqrt( sum(U[, L]^2) )
    U[, L] <- U[, L] * scl # orthonormalize
    R[, L] <- R[, L] * scl
  }
  
  # loop on higher degrees, applying Gram-Schmidt only on similar
  # parity functions (as even/odd are already orthogonal in U)
  if( P > 2 ) {
    for(L in 3:P) {
      if(L %% 2 == 0) {
        Kmin <- 2
      } else {
        Kmin <- 1
      }
      for(j in seq(Kmin, L-1, 2)) {
        scl <- sum( U[, L] * U[, j] )
        U[, L] <- U[, L] - scl * U[, j] # Gram-Schmidt
        R[, L] <- R[, L] - scl * R[, j]
      }
      scl <- 1 / sqrt(sum(U[, L]^2))
      U[, L] <- U[, L] * scl  # orthonormalize
      R[, L] <- R[, L] * scl
    }
  }
  
  Hn <- colSums(R^2)
  return(list(U,R,Hn))
}

removePeriod <- function(xd, f0, nw, k, deltaT, warn=FALSE, prec=1e-10, sigClip) {
  
  # xd : data
  # f0 : freq of periodicty to remove
  # nw, k : parameters of multitaper
  # deltaT : parameter of xd
  # prec.st : starting precision for finding a good nFFT for removal
  
  # check to make sure f0 is reasonable, otherwise warn
  N <- length(xd)
  spec.t <- spec.mtm(xd,nw=nw,k=k,Ftest=T,plot=F,nFFT=2^(floor(log(N,2))+2),deltat=deltaT)
  idx <- max(which(spec.t$freq < f0))
  if( max(spec.t$mtm$Ftest[idx],spec.t$mtm$Ftest[idx]) < qf(sigClip,2,(2*k-2)) && warn ) {
    warning("Ftest at frequency f0 not significant. Are you sure you want to remove this?")
  }
  
  # early parameter setup, find a nFFT that gives a bin *very* close to f0, or on top of it
  Nyq <- 1/2/deltaT
  nFFT <- -1
  prec.st <- prec
  while( nFFT < 0 ) {
    nFFT <- findPowers(N,f0,Nyq,prec.st)
    prec.st <- prec.st*10
  }
  
  spec <- spec.mtm(xd,nw=nw,k=k,returnInternals=T,Ftest=T,plot=F,nFFT=nFFT,maxAdaptiveIterations=0,
                   deltat=deltaT)
  
  # parameter setup
  w <- nw/N/deltaT
  df <- 1/nFFT/deltaT
  neh <- max(10,(floor((2*w)/df+1)))
  f0.idx <- seq(along=spec$freq)[spec$freq == (f0 - min(abs(spec$freq - f0))) | spec$freq == (f0 + min(abs(spec$freq - f0)))]
  
  ##########################################################################
  # 
  #  All spectral window work will require the full spectral array
  # 
  ##########################################################################
  # form spectral windows
  dw <- dpss(N,k,5.0)$v*sqrt(deltaT)
  # zero-pad
  dw.z <- rbind(dw,matrix(data=0,nrow=(spec$mtm$nFFT-N),ncol=k))
  # empty window array, nFFT x k
  sw <- matrix(data=0,nrow=spec$mtm$nFFT,ncol=k)
  for(j in 1:k) {
    ft <- fft(dw.z[,j])
    sw[,j] <- c(ft[(spec$mtm$nfreqs+1):spec$mtm$nFFT],ft[1:spec$mtm$nfreqs])
  }
  
  # form estimate of chosen frequency component - takes 0+/- neh from the spectral
  #   window and expands it by multiplying by the CMV at f0
  est <- matrix(data=complex(0,0),nrow=(2*neh+1),ncol=k)
  for(j in 1:k) {
    est[,j] <- spec$mtm$cmv[f0.idx]*(sw[((spec$mtm$nfreqs-1)-neh):((spec$mtm$nfreqs-1)+neh),j])
  }
  
  # subtract from original eigencoefficients
  egn <- spec$mtm$eigenCoefs
  egn <- rbind(Conj(egn[2:spec$mtm$nfreqs,]), egn)
  range <- (f0.idx-neh+spec$mtm$nfreqs) : (f0.idx+neh+spec$mtm$nfreqs)
  if(max(range) > nFFT) {
    # case of folding over the top, i.e. freq too close to Nyq+
    fold <- which(range > nFFT)
    rangeF <- range[fold]
    rangeN <- range[-fold]
    range <- c(1:length(rangeF), rangeN)
  } 
  est2 <- est
  for(j in 1:k) {
    est2[which(range < spec$mtm$nfreqs),j] <- Conj(est2[which(range < spec$mtm$nfreqs),j])
    egn[range,j] <- egn[range,j] - est2[,j]
  }
  
  blank <- matrix(data=0,nrow=nFFT,ncol=1)
  blank[f0.idx] <- spec$mtm$cmv[f0.idx]
  blank[nFFT-f0.idx+2] <- Conj(spec$mtm$cmv[f0.idx])
  inv <- fft(blank,inverse=T)
  inv <- Re(inv)[1:N]
  
  #  cat(paste("Freq: ", spec$freq[f0.idx]," \n",
  #            "Amp : ", sqrt(Mod(spec$mtm$cmv[f0.idx])), "\n",
  #            "Phse: ", Arg(spec$mtm$cmv[f0.idx]), "\n", sep=""))
  return(inv)
}

findPowers <- function(N,f0,Nyq,prec) {
  nFFT <- 1e30
  
  low2 <- 0
  high2 <- floor(log(N,2))+2
  low3 <- 0
  high3 <- floor(log(N,3))+2
  low5 <- 0
  high5 <- floor(log(N,5))+2
  low7 <- 0
  high7 <- floor(log(N,7))+2
  for(i in low2:high2) {
    for(j in low3:high3) {
      for(k in low5:high5) {
        for(l in low7:high7) {
          att <- 2^i * 3^j * 5^k * 7^l
          if((att > 2*N) & att < 100*N) {
            df <- (Nyq*2)/att
            if( abs(trunc(f0/df)*df - f0) < prec ) {
              if(att < nFFT) {
                nFFT <- att 
              }
            }
          } # big enough
        } # end of 7
      } # end of 5
    } # end of 3
  } # end of 2
  if(nFFT == 1e30) {
    return(-1)
  } else {
    return(nFFT)
  }
}


```

## Three Approaches for Training Data Simulation

The Neural Network Imputer relies on these four libraries specifically:

```{r setup2, message = FALSE}
library(tsinterp)
library(interpTools)
library(tensorflow)
library(keras)
```

```{r setup3, message = FALSE, warning=FALSE, fig.align='center', fig.dim=c(8,5), echo =FALSE}
## Additional Libraries:
library(latex2exp)
library(scales)


## Defining the time series for demo
set.seed(42)
N = 100
x = simXt(N = N, mu = 0, numTrend = 1, numFreq = 2)$Xt
#x = (x - min(x)) / (max(x) - min(x))
#x_gapped = simulateGaps(list(xt), p = 0.1, g = 1, K = 1)
#x_gappy = x_gapped[[1]]$p0.1$g1[[1]]
plot(x, type = 'l', main = 'Input Time Series', xlab = 'Time', ylab = 'X', lwd = 2); grid()
#lines(which(is.na(x_gappy)), xt[is.na(x_gappy)], type = 'p', col = 'black', pch = 21, bg = 'red')
#legend('topleft', legend = c('Missing Data Point'), col = 'red', pch = 16, cex = 1.2)
```

\newpage

## Method 1:
0. Input a complete time series.
1. Estimate the trend and periodic component(s).
2. Compute the residual noise between the estimate series and the input series.
3. Perturb the noise series (using multiplication of complex vector).
4. Add the perturbed noise back to the estimate series.

```{r noise_process, fig.align='center', fig.dim=c(8,5)}
xE = estimator(x, method = 'Xt')      ## Estimate trend + periodic and noise components
w = x - xE                            ## Computing the residual noise
w_f = fft(w, inverse = FALSE)         ## Converting noise to frequency domain
inputs = c()                          ## Initializing vector to store values

Mod_a = 0.95; Mod_b = 1.05            ## Defining Modulus and Argument values
Arg_a = -pi/6; Arg_b = pi/6

for (i in 1:10){
  
  ## Creating small perturbation
  w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
  
  w_t = as.numeric(fft(w_p, inverse = TRUE)) / N  ## Converting back to time domain
  x_p = xE + w_t                                  ## Adding perturbed noise back
  inputs = c(inputs, x_p)                         ## Saving the new series
}
```

```{r noise_process2, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = array(matrix(inputs, nrow = 10, byrow = TRUE), dim = c(10, N))

colour = 'red'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 1'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{6}, \\frac{pi}{6})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r method1_func, echo = FALSE}
method_1 <- function(Mod_a, Mod_b, Arg_a, Arg_b){
  xE = estimator(x, method = 'Xt')      ## Estimate trend + periodic and noise components
  w = x - xE                            ## Computing the residual noise
  w_f = fft(w, inverse = FALSE)         ## Converting noise to frequency domain
  inputs = c()                          ## Initializing vector to store values

  for (i in 1:10){
  
    ## Creating small perturbation
    w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
  
    w_t = as.numeric(fft(w_p, inverse = TRUE)) / N  ## Converting back to time domain
    x_p = xE + w_t                                  ## Adding perturbed noise back
    inputs = c(inputs, x_p)                         ## Saving the new series
  }
  inputs = array(matrix(inputs, nrow = 10, byrow = TRUE), dim = c(10, N))
  return(inputs)
}
```

\newpage

### Method 1 w/ different Mod and Arg values:

```{r noise_process3, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_1(0.95, 1.05, -pi/4, pi/4)

colour = 'dodgerblue'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 1'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{4}, \\frac{pi}{4})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process4, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_1(0.95, 1.05, -pi/2, pi/2)

colour = 'forestgreen'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 1'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{2}, \\frac{pi}{2})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process5, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_1(0.9, 1.1, -pi/6, pi/6)

colour = 'red'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 1'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{6}, \\frac{pi}{6})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process6, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_1(0.9, 1.1, -pi/4, pi/4)

colour = 'dodgerblue'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 1'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{4}, \\frac{pi}{4})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process7, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_1(0.9, 1.1, -pi/2, pi/2)

colour = 'forestgreen'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 1'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{2}, \\frac{pi}{2})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```


\newpage

## Method 2:
0. Input a complete time series.
1. Estimate trend component.
2. De-trend and zero-mean the input series.
3. Perturb the de-trended series (using multiplication of complex vector).
4. Add the mean and trend back to the perturbed series.


```{r noise_process_all, fig.align='center', fig.dim=c(8,5)}
Mt = estimator(x, method = 'Mt')     ## Estimating trend component
Y = x - Mt                            ## De-trending
Z = Y - mean(Y)                       ## Removing the mean
Z_f = fft(Z, inverse = FALSE)         ## Converting to frequency domain
inputs = c()                          ## Initializing vector to store values

Mod_a = 0.95; Mod_b = 1.05            ## Defining Modulus and Argument values
Arg_a = -pi/6; Arg_b = pi/6

for (i in 1:10){
  
  ## Creating small perturbation
  Z_p = Z_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))

  Z_t = as.numeric(fft(Z_p, inverse = TRUE)) / N  ## Converting back to time domain
  x_p = Z_t + mean(Y) + Mt                        ## Adding mean and trend back
  inputs = c(inputs, x_p)                         ## Saving the new series
}
```

```{r noise_process_all2, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = array(matrix(inputs, nrow = 10, byrow = TRUE), dim = c(10, N))

colour = 'red'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 2'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{6}, \\frac{pi}{6})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r method2_func, echo = FALSE}
method_2 <- function(Mod_a, Mod_b, Arg_a, Arg_b){
  Mt = estimator(x, method = 'Mt')     ## Estimating trend component
  Y = x - Mt                            ## De-trending
  Z = Y - mean(Y)                       ## Removing the mean
  Z_f = fft(Z, inverse = FALSE)         ## Converting to frequency domain
  inputs = c()                          ## Initializing vector to store values

  for (i in 1:10){
  
    ## Creating small perturbation
    Z_p = Z_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))

    Z_t = as.numeric(fft(Z_p, inverse = TRUE)) / N  ## Converting back to time domain
    x_p = Z_t + mean(Y) + Mt                        ## Adding mean and trend back
    inputs = c(inputs, x_p)                         ## Saving the new series
  }
  inputs = array(matrix(inputs, nrow = 10, byrow = TRUE), dim = c(10, N))
  return(inputs)
}
```

\newpage

### Method 2 w/ different Mod and Arg values:

```{r noise_process_all3, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_2(0.95, 1.05, -pi/4, pi/4)

colour = 'dodgerblue'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 2'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{4}, \\frac{pi}{4})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_all4, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_2(0.95, 1.05, -pi/2, pi/2)

colour = 'forestgreen'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 2'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{2}, \\frac{pi}{2})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_all5, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_2(0.9, 1.1, -pi/6, pi/6)

colour = 'red'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 2'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{6}, \\frac{pi}{6})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_all6, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_2(0.9, 1.1, -pi/4, pi/4)

colour = 'dodgerblue'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 2'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{4}, \\frac{pi}{4})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_all7, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_2(0.9, 1.1, -pi/2, pi/2)

colour = 'forestgreen'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 2'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{2}, \\frac{pi}{2})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

\newpage

## Method 3:
0. Input a complete time series.
1. Estimate the trend and periodic component(s).
2. Compute the residual noise between the estimate series and the input series.
3. Perturb the noise series (using multiplication of complex vector).
4. Perturb the estimate series (using multiplication of complex vector).
5. Add the perturbed noise back to the perturbed estimate series.


```{r noise_process_sep, fig.align='center', fig.dim=c(8,5)}
xE = estimator(x, method = 'Xt')      ## Estimate trend + periodic and noise components
w = x - xE                            ## Computing the residual noise
w_f = fft(w, inverse = FALSE)         ## Converting noise to frequency domain
xE_f = fft(xE, inverse = FALSE)       ## Converting estimate to frequency domain
inputs = c()                          ## Initializing vector to store values

Mod_a = 0.95; Mod_b = 1.05            ## Defining Modulus and Argument values
Arg_a = -pi/6; Arg_b = pi/6

for (i in 1:10){
  
  ## Creating small perturbation
  w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
  xE_p = xE_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
  
  w_t = as.numeric(fft(w_p, inverse = TRUE)) / N    ## Converting back to time domain
  xE_t = as.numeric(fft(xE_p, inverse = TRUE)) / N  
  
  x_p = xE_t + w_t                                  ## Adding perturbed noise back
  inputs = c(inputs, x_p)                           ## Saving the new series
}
```

```{r noise_process_sep2, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = array(matrix(inputs, nrow = 10, byrow = TRUE), dim = c(10, N))

colour = 'red'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 3'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{6}, \\frac{pi}{6})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r method3_func, echo = FALSE}
method_3 <- function(Mod_a, Mod_b, Arg_a, Arg_b){
  xE = estimator(x, method = 'Xt')      ## Estimate trend + periodic and noise components
  w = x - xE                            ## Computing the residual noise
  w_f = fft(w, inverse = FALSE)         ## Converting noise to frequency domain
  xE_f = fft(xE, inverse = FALSE)       ## Converting estimate to frequency domain
  inputs = c()                          ## Initializing vector to store values

  for (i in 1:10){
  
    ## Creating small perturbation
    w_p = w_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
    xE_p = xE_f * complex(modulus = runif(N, Mod_a, Mod_b), argument = runif(N, Arg_a, Arg_b))
  
    w_t = as.numeric(fft(w_p, inverse = TRUE)) / N    ## Converting back to time domain
    xE_t = as.numeric(fft(xE_p, inverse = TRUE)) / N  
  
    x_p = xE_t + w_t                                  ## Adding perturbed noise back
    inputs = c(inputs, x_p)                           ## Saving the new series
  }
  inputs = array(matrix(inputs, nrow = 10, byrow = TRUE), dim = c(10, N))
  return(inputs)
}
```

\newpage

### Method 3 w/ different Mod and Arg values:

```{r noise_process_sep3, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_3(0.95, 1.05, -pi/4, pi/4)

colour = 'dodgerblue'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 3'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{4}, \\frac{pi}{4})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_sep4, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_3(0.95, 1.05, -pi/2, pi/2)

colour = 'forestgreen'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 3'
subtitle = TeX('$Mod = runif(0.95, 1.05), Arg = runif(\\frac{-pi}{2}, \\frac{pi}{2})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_sep5, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_3(0.9, 1.1, -pi/6, pi/6)

colour = 'red'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 3'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{6}, \\frac{pi}{6})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_sep6, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_3(0.9, 1.1, -pi/4, pi/4)

colour = 'dodgerblue'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 3'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{4}, \\frac{pi}{4})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```

```{r noise_process_sep7, fig.align='center', fig.dim=c(8,5), echo=FALSE}
inputs = method_3(0.9, 1.1, -pi/2, pi/2)

colour = 'forestgreen'

plot(inputs[1,], type = 'l', col = alpha(colour, 0.3), xlab = 'Time', ylab = 'X')
lines(inputs[2,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[3,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[4,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[5,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[6,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[7,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[8,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[9,], type = 'l', col = alpha(colour, 0.3))
lines(inputs[10,], type = 'l', col = alpha(colour, 0.3))

lines(x, type = 'l', col = 'black', lwd = 2); grid()

legend('topleft', c('Original', 'Simulated'), lty = 1, lwd = 2, cex = 0.8, col = c('black', colour))

title = 'Data Simulation Method 3'
subtitle = TeX('$Mod = runif(0.9, 1.1), Arg = runif(\\frac{-pi}{2}, \\frac{pi}{2})$')
mtext(line = 2.2, title, cex = 1.25)
mtext(line = 0.4, subtitle, cex = 0.75)
```