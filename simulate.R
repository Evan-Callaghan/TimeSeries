########################################
## Neural Network Time Series Imputer ##
########################################

## SIMULATOR: All code related to generating Neural Network training data


## Importing libraries
## -----------------------

library(tsinterp)
library(interpTools)

## Notation Notes
## -----------------------

#' @param x0 {list}; List containing the original incomplete time series ("x naught")
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param xE {list}; List containing the current trend + periodic estimates of xV ("x estimate")
#' "_t"; Signifies a series being converted to the time domain 
#' "_f"; Signifies a series being converted to the frequency domain 
#' "_p"; Signifies a perturbed series
#' "_g"; Signifies a series with gaps imposed on it

## Defining all functions
## -----------------------

#' simulator
#' 
#' Main function for the "simulate" file. The "case" parameter determines which method is used
#' to generate the neural network training data:
#' 
#' Case 1: Data is generated by first estimating the trend and periodic components, computing the 
#' residual noise between the estimate and the current version of the imputed series, 
#' perturbing the noise series, and then adding the perturbed noise back to the estimate series.
#' 
#' Case 2: 
#' 
#' Case 3: 
#' unction to simulate a number of time series with on slight perturbations given the estimated
#' structure of the original time series. With each new series, a specified gap structure is 
#' imposed and returned are two data matrices: one with missing gaps (inputs) and one that is
#' complete (targets). Completes the third and fourth steps of the designed algorithm.
#' @param x0 {list}; List object containing a the original incomplete time series 
#' @param xV {list}; List object containing a complete time series (i.e., up-to-date imputation)
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' @param case {string}; ...
#' 
simulator <- function(x0, xV, n_series, p, g, K, random = TRUE, case = 'noise'){
  
  ## Case 1:
  if (case == 'noise'){
    xE = estimator(xV) ## Estimating trend + period
    data = simulator_noise(x0, xV, xE, n_series, p, g, K, random = TRUE) ## Simulating data
    inputs = data[[1]]; targets = data[[2]]
    return(list(inputs, targets))
  }
  
  ## Case 2: Data is generated by 
  else if (case == 'all'){
    # Do something...
  }
  else if (case == 'separate'){
    # Do something...
  }
}






#' simulator_noise
#' 
#' Function to simulate a number of time series with on slight perturbations given the estimated
#' structure of the original time series. With each new series, a specified gap structure is 
#' imposed and returned are two data matrices: one with missing gaps (inputs) and one that is
#' complete (targets). Completes the third and fourth steps of the designed algorithm.
#' @param x0 {list}; 
#' @param xI {list}; 
#' @param xE {list}; 
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' 
simulator_noise <- function(x0, xV, xE, n_series, p, g, K, random = TRUE){
  if (random == FALSE){K = 1}
  N = length(xV); M = n_series * K ## Defining useful parameters
  inputs_temp = c(); targets_temp = c() ## Initializing vectors to store values
  w = xV - xE ## Computing the residual noise
  w_f = fft(w, inverse = FALSE) ## Converting noise to frequency domain
  
  if (random == TRUE){
    for (i in 1:n_series){
      w_p = w_f * complex(modulus = runif(N, 0.97, 1.03), argument = runif(N, -pi/6, pi/6)) ## Creating small perturbation
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE + w_t ## Adding perturbed noise back to trend and periodic
      x_g = simulateGaps(list(x_p), p = p, g = g, K = K) ## Imposing gap structure
      
      for (k in 1:K){
        structure = paste0('x_g[[1]]$p', p, '$g', g, '[[k]]')
        inputs_temp = c(inputs_temp, eval(parse(text = structure))) ## Appending inputs
        targets_temp = c(targets_temp, xE_p) ## Appending targets
      }
    }
  }
  
  else if (random == FALSE){
    g_index = which(is.na(x0)) ## Defining useful parameters
    for (i in 1:n_series){
      w_p = w_f * complex(modulus = runif(N, 0.97, 1.03), argument = runif(N, -pi/6, pi/6)) ## Creating small perturbation
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE + w_t ## Adding perturbed noise back to trend and periodic
      x_g = x_p; x_g[g_index] = NA ## Imposing non-randomized gap structure
      inputs_temp = c(inputs_temp, x_g) ## Appending inputs
      targets_temp = c(targets_temp, x_p) ## Appending targets
    }
  }
  
  inputs = array(matrix(inputs_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting inputs
  targets = array(matrix(targets_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting targets
  preprocessed = preprocess(inputs, targets) ## Preprocessing
  inputs = preprocessed[[1]]; targets = preprocessed[[2]]
  return(list(inputs, targets))
}

