########################################
## Neural Network Time Series Imputer ##
########################################

## SIMULATOR: All code related to generating Neural Network training data


## Importing libraries
## -----------------------

library(tsinterp)
library(interpTools)

## Notation Notes
## -----------------------

#' @param x0 {list}; List containing the original incomplete time series ("x naught")
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param xE {list}; List containing the current trend + periodic estimates of xV ("x estimate")
#' "_t"; Signifies a series being converted to the time domain 
#' "_f"; Signifies a series being converted to the frequency domain 
#' "_p"; Signifies a perturbed series
#' "_g"; Signifies a series with gaps imposed on it

## Defining all functions
## -----------------------

#' simulator
#' 
#' Main function for the "simulate" file. The "method" parameter determines which method is used
#' to generate the neural network training data:
#' 
#' Method 1: Data is generated by first estimating the trend and periodic components, computing the 
#' residual noise between the estimate and the current version of the imputed series, perturbing the 
#' noise series, and then adding the perturbed noise back to the estimate series.
#' 
#' Method 2: Data is generated by first removing the trend and the mean, perturbing the de-trended
#' series, and then adding the mean and trend back to the perturbed series.
#' 
#' Method 3: Data is generated by first estimating the trend and periodic components, computing the 
#' residual noise between the estimate and the current version of the imputed series, perturbing the 
#' noise series, perturbing the trend + periodic series, and then adding the two perturbed series 
#' back together.
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' @param method {string}; Method for data simulation in c('noise', 'all', 'separate')
#' 
simulator <- function(x0, xV, n_series, p, g, K, random = TRUE, method = 'noise', Mod, Arg){
  
  ## Case 1:
  if (method == 'noise'){
    xE = estimator(xV, method = 'Xt') ## Estimating trend + period
    data = simulator_noise(x0, xV, xE, n_series, p, g, K, random, Mod, Arg) ## Simulating data
    inputs = data[[1]]; targets = data[[2]]
    return(list(inputs, targets))
  }
  
  ## Case 2: Data is generated by 
  else if (method == 'all'){
    Mt = estimator(xV, method = 'Mt') ## Estimating trend
    data = simulator_all(x0, xV, Mt, n_series, p, g, K, random, Mod, Arg) ## Simulating data
    inputs = data[[1]]; targets = data[[2]]
    return(list(inputs, targets))
    # Do something...
  }
  else if (method == 'separate'){
    xE = estimator(xV, method = 'Xt') ## Estimating trend + period
    data = simulator_separate(x0, xV, xE, n_series, p, g, K, random, Mod, Arg) ## Simulating data
    inputs = data[[1]]; targets = data[[2]]
    return(list(inputs, targets))
  }
}


#' simulator_noise
#' 
#' Function to simulate training data for method = 'noise' (i.e., follows Method 1 described above).
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param xE {list}; List containing the current trend + periodic estimates of xV ("x estimate")
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' 
simulator_noise <- function(x0, xV, xE, n_series, p, g, K, random = TRUE, Mod, Arg){
  if (random == FALSE){K = 1}
  N = length(xV); M = n_series * K ## Defining useful parameters
  inputs_temp = c(); targets_temp = c() ## Initializing vectors to store values
  w = xV - xE ## Computing the residual noise
  w_f = fft(w, inverse = FALSE) ## Converting noise to frequency domain
  
  if (random == TRUE){
    for (i in 1:n_series){
      w_p = w_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg)) ## Creating small perturbation
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE + w_t ## Adding perturbed noise back to trend and periodic
      x_g = simulateGaps(list(x_p), p = p, g = g, K = K) ## Imposing gap structure
      
      for (k in 1:K){
        structure = paste0('x_g[[1]]$p', p, '$g', g, '[[k]]')
        inputs_temp = c(inputs_temp, eval(parse(text = structure))) ## Appending inputs
        targets_temp = c(targets_temp, x_p) ## Appending targets
      }
    }
  }
  
  else if (random == FALSE){
    g_index = which(is.na(x0)) ## Defining useful parameters
    for (i in 1:n_series){
      w_p = w_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg)) ## Creating small perturbation
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE + w_t ## Adding perturbed noise back to trend and periodic
      x_g = x_p; x_g[g_index] = NA ## Imposing non-randomized gap structure
      inputs_temp = c(inputs_temp, x_g) ## Appending inputs
      targets_temp = c(targets_temp, x_p) ## Appending targets
    }
  }
  
  inputs = array(matrix(inputs_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting inputs
  targets = array(matrix(targets_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting targets
  preprocessed = preprocess(inputs, targets) ## Preprocessing
  inputs = preprocessed[[1]]; targets = preprocessed[[2]]
  return(list(inputs, targets))
}


#' simulator_all
#' 
#' Function to simulate training data for method = 'all' (i.e., follows Method 2 described above).
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param Mt {list}; List containing the estimated trend component
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' 
simulator_all <- function(x0, xV, Mt, n_series, p, g, K, random = TRUE, Mod, Arg){
  if (random == FALSE){K = 1}
  N = length(xV); M = n_series * K ## Defining useful parameters
  inputs_temp = c(); targets_temp = c() ## Initializing vectors to store values
  
  Y = xV - Mt ## De-trending
  Z = Y - mean(Y) ## Zero-mean
  
  Z_f = fft(Z, inverse = FALSE) ## Converting noise to frequency domain
  
  if (random == TRUE){
    for (i in 1:n_series){
      Z_p = Z_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg)) ## Creating small perturbation
      Z_t = as.numeric(fft(Z_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = Z_t + mean(Y) + Mt ## Adding perturbed noise back to trend and periodic
      x_g = simulateGaps(list(x_p), p = p, g = g, K = K) ## Imposing gap structure
      
      for (k in 1:K){
        structure = paste0('x_g[[1]]$p', p, '$g', g, '[[k]]')
        inputs_temp = c(inputs_temp, eval(parse(text = structure))) ## Appending inputs
        targets_temp = c(targets_temp, x_p) ## Appending targets
      }
    }
  }
  
  else if (random == FALSE){
    g_index = which(is.na(x0)) ## Defining useful parameters
    for (i in 1:n_series){
      Z_p = Z_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg)) ## Creating small perturbation
      Z_t = as.numeric(fft(Z_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = Z_t + mean(Y) + Mt ## Adding perturbed noise back to trend and periodic
      x_g = x_p; x_g[g_index] = NA ## Imposing non-randomized gap structure
      inputs_temp = c(inputs_temp, x_g) ## Appending inputs
      targets_temp = c(targets_temp, x_p) ## Appending targets
    }
  }
  
  inputs = array(matrix(inputs_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting inputs
  targets = array(matrix(targets_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting targets
  preprocessed = preprocess(inputs, targets) ## Preprocessing
  inputs = preprocessed[[1]]; targets = preprocessed[[2]]
  return(list(inputs, targets))
}


#' simulator_separate
#' 
#' Function to simulate training data for method = 'separate' (i.e., follows Method 3 described above).
#' @param x0 {list}; List containing the original incomplete time series ("x naught") 
#' @param xV {list}; List containing the current version of imputed series ("x version")
#' @param xE {list}; List containing the current trend + periodic estimates of xV ("x estimate")
#' @param n_series {integer}; Number of new time series to construct
#' @param p {flaot}; Proportion of missing data to be applied to the simulated series
#' @param g {integer}; Gap width of missing data to be applied to the simulated series
#' @param K {integer}; Number of output series with a unique gap structure for each simulated series
#' @param random {boolean}; Indicator of whether or not the gap placement is randomized
#' 
simulator_separate <- function(x0, xV, xE, n_series, p, g, K, random = TRUE, Mod, Arg){
  if (random == FALSE){K = 1}
  N = length(xV); M = n_series * K ## Defining useful parameters
  inputs_temp = c(); targets_temp = c() ## Initializing vectors to store values
  w = xV - xE ## Computing the residual noise
  xE_f = fft(xE, inverse = FALSE) ## Converting estimate to frequency domain
  w_f = fft(w, inverse = FALSE) ## Converting noise to frequency domain
  
  if (random == TRUE){
    for (i in 1:n_series){
      xE_p = xE_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg))
      w_p = w_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg))
      xE_t = as.numeric(fft(xE_p, inverse = TRUE)) / N ## Converting back to time domain
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE_t + w_t ## Adding perturbed noise back to trend and periodic
      x_g = simulateGaps(list(x_p), p = p, g = g, K = K) ## Imposing gap structure
      
      for (k in 1:K){
        structure = paste0('x_g[[1]]$p', p, '$g', g, '[[k]]')
        inputs_temp = c(inputs_temp, eval(parse(text = structure))) ## Appending inputs
        targets_temp = c(targets_temp, x_p) ## Appending targets
      }
    }
  }
  
  else if (random == FALSE){
    g_index = which(is.na(x0)) ## Defining useful parameters
    for (i in 1:n_series){
      xE_p = xE_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg))
      w_p = w_f * complex(modulus = runif(N, 1-Mod, 1+Mod), argument = runif(N, 0-Arg, 0+Arg))
      xE_t = as.numeric(fft(xE_p, inverse = TRUE)) / N ## Converting back to time domain
      w_t = as.numeric(fft(w_p, inverse = TRUE)) / N ## Converting back to time domain
      x_p = xE_t + w_t ## Adding perturbed noise back to trend and periodic
      x_g = x_p; x_g[g_index] = NA ## Imposing non-randomized gap structure
      inputs_temp = c(inputs_temp, x_g) ## Appending inputs
      targets_temp = c(targets_temp, x_p) ## Appending targets
    }
  }
  
  inputs = array(matrix(inputs_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting inputs
  targets = array(matrix(targets_temp, nrow = M, byrow = TRUE), dim = c(M, N)) ## Properly formatting targets
  preprocessed = preprocess(inputs, targets) ## Preprocessing
  inputs = preprocessed[[1]]; targets = preprocessed[[2]]
  return(list(inputs, targets))
}


#' preprocess
#' 
#' Function to preprocess the data before building the neural network imputer. The function performs 0-1
#' standardization for each time series in the input and target matrix.
#' @param inputs {matrix}; Matrix object containing the input training data (i.e., an incomplete 
#'                         time series in each row)
#' @param targets {matrix}; Matrix object containing the target training data (i.e., a complete 
#'                         time series in each row)
#' 
preprocess <- function(inputs, targets){
  for (i in 1:dim(inputs)[1]){
    inputs[i,] = (inputs[i,] - min(targets[i,])) / (max(targets[i,]) - min(targets[i,])) 
    targets[i,] = (targets[i,] - min(targets[i,])) / (max(targets[i,]) - min(targets[i,]))
    
    inputs[i,] = ifelse(is.na(inputs[i,]), -1, inputs[i,])
  }
  return(list(inputs, targets))
}